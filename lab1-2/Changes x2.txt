1. Связь WorkSchedule—>OfficeHours.
Я действительно ввел свойство, что WorkSchedule::office_hours_id может быть NULL, а значит, каждому экземпляру одной сущности WorkSchedule может либо соотвествовать один экземпляр сущности OfficeHours, а может и не соотвествовать. Поэтому ее кратность будет 0..1
Не уходя далеко, сразу рассмотрим обратную связь OfficeHours->WorkSchedule:
Каждой строке в OfficeHours может соотвествовать сколь угодно много строк из WorkSchedule (в т.ч. 0), а значит, это связь 0..n (Моя же 1..n показывала, что для каждого возможного времени должен точно существовать сотрудник в какой-то день, который работает по этому времени, что, собственно говоря, не факт).


Рассмотрим остальные связи.

WorkSchedule->WeekDay и WorkScedule->Employees: 1..1 - тут все верно, т.к. первичный ключ -составной, и соотвествующие поля не могут быть NULL.
2. Однако WeekDay->WorkSchedule и Employees->WorkSchedule будут 0..n
Хотя и можно было бы привязать к легенде те факты, что в каждый из дней недель хотя бы кто-то из работников должен да работать, и что каждый служащий должен работать хотя бы в один день, но т.к. обратная связь 1..1, а не 0..1, то, как Вами было справдливо замечено, это технически невозможно реализовать (всм, инициализировать таблицы хотя бы одним экземпляром). То есть тогда бы пришлость менять кратность обратной связи с 1..1 на 0..1, а в этом случае составной ключ не будет первичным (раз может быть NULL), что, вообще говоря, будет не логично.


P.S. Это приводит нас к одной гениально-простой мысли: в связи A->B, где атрибут A выступает первичным ключом и ссылкой к сущности B, где он не может быть NULL (т.е. обратная связь кратности 1..1), кратностей  1..1 / 1..x быть не может в принципе, т.к. если для каждого ключа в таблице 'A' должен УЖЕ существовать экземпляр в таблице 'B', то как нам добавить новый (в т.ч., первый) ключ в 'A' (ибо таблица 'B' не даст создать экземпляр, ссылающийся на ключ в 'A', которого еще нет)? Короче говоря, 1..1/n - 1..1/n существовать не могет.

Поэтому пусть по легенде могут существовать выходные дни (в которые можно кого-то поставить, а можно не ставить), а работники могут уйти в отпуск (т.е. не будут иметь записей о своем расписании): 0..n


3. По той же логике (невозможности реализации связи 1 - 1..n) меняем в AccessLevels, StatusStates, Posts и Departments связи 1..n на 0..n (т.к. в обратных связях это первичные ключи)

AssignedCases->Employees и AssignedCases->Cases: не знаю, почему я там 1..n поставил; разумеется, там 1..1 (иначе нафига я вообще делал эту таблицу-связку);

P.P.S. В таблице Cases все внешние ключи - NOT NULL (в скрипте при создании БД я это учел, а показать на ERD забыл, теперь пофикшено);
